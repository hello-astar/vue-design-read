<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>hello</title>
    </head>
    <body>
        <div id="app">
        </div>
    </body>
</html>
<script type="text/javascript">
const VNodeFlags = {
  // html 标签
  ELEMENT_HTML: 1,
  // SVG 标签C:\Users\Administrator\Desktop\astar\vue\index (2).html
  ELEMENT_SVG: 1 << 1,

  // 普通有状态组件
  COMPONENT_STATEFUL_NORMAL: 1 << 2,
  // 需要被keepAlive的有状态组件
  COMPONENT_STATEFUL_SHOULD_KEEP_ALIVE: 1 << 3,
  // 已经被keepAlive的有状态组件
  COMPONENT_STATEFUL_KEPT_ALIVE: 1 << 4,
  // 函数式组件
  COMPONENT_FUNCTIONAL: 1 << 5,

  // 纯文本
  TEXT: 1 << 6,
  // Fragment
  FRAGMENT: 1 << 7,
  // Portal
  PORTAL: 1 << 8,
}
VNodeFlags.ELEMENT = VNodeFlags.ELEMENT_HTML | VNodeFlags.ELEMENT_SVG
VNodeFlags.COMPONENT = VNodeFlags.COMPONENT_STATEFUL_NORMAL | VNodeFlags.COMPONENT_STATEFUL_SHOULD_KEEP_ALIVE | VNodeFlags.COMPONENT_STATEFUL_KEPT_ALIVE | VNodeFlags.COMPONENT_FUNCTIONAL
VNodeFlags.COMPONENT_STATEFUL = VNodeFlags.COMPONENT_STATEFUL_NORMAL | VNodeFlags.COMPONENT_STATEFUL_SHOULD_KEEP_ALIVE | VNodeFlags.COMPONENT_STATEFUL_KEPT_ALIVE
const ChildrenFlags = {
  // 未知的 children 类型
  UNKNOWN_CHILDREN: 0,
  // 没有 children
  NO_CHILDREN: 1,
  // children 是单个 VNode
  SINGLE_VNODE: 1 << 1,

  // children 是多个拥有 key 的 VNode
  KEYED_VNODES: 1 << 2,
  // children 是多个没有 key 的 VNode
  NONE_KEYED_VNODES: 1 << 3
}
ChildrenFlags.MULTIPLE_VNODES = ChildrenFlags.KEYED_VNODES | ChildrenFlags.NONE_KEYED_VNODES

const Fragment = Symbol()
const Portal = Symbol()
const normalizeVNodes = function (children) {
  const newChildren = []
  // 遍历 children
  for (let i = 0; i < children.length; i++) {
    const child = children[i]
    if (child.key == null) {
      // 如果原来的 VNode 没有key，则使用竖线(|)与该VNode在数组中的索引拼接而成的字符串作为key
      child.key = '|' + i
    }
    newChildren.push(child)
  }
  // 返回新的children，此时 children 的类型就是 ChildrenFlags.KEYED_VNODES
  return newChildren
}
const createTextVNode = function (text) {
    return {
        _isVNode: true,
        flags: VNodeFlags.TEXT,
        tag: null,
        data: null,
        children: text,
        childFlags: ChildrenFlags.SINGLE_VNODE,
        el: null
    }
}
const h = function (tag, data = null, children = null) {
    let flags = null
    if (typeof tag === 'string') {
        flags = tag === 'svg' ? VNodeFlags.ELEMENT_SVG : VNodeFlags.ELEMENT_HTML
    } else if (tag === Fragment) {
        flags = VNodeFlags.FRAGMENT
    } else if (tag === Portal) {
        flags = VNodeFlags.PORTAL
        tag = data && data.target
    } else {
        if (tag !== null && typeof tag === 'object') {
            flags = tag.functional
                ? VNodeFlags.COMPONENT_FUNCTIONAL
                : VNodeFlags.COMPONENT_STATEFUL_NORMAL
        } else if (typeof tag === 'function') {
            flags = tag.prototype && tag.prototype.render
                ? VNodeFlags.COMPONENT_STATEFUL_NORMAL  // 有状态组件
                : VNodeFlags.COMPONENT_FUNCTIONAL       // 函数式组件
        }
    }

    // 确定childFlags
    let childFlags = null
    if (Array.isArray(children)) {
        const { length } = children
        if (length === 0) {
            childFlags = ChildrenFlags.NO_CHILDREN
        } else if (length === 1) {
            childFlags = ChildrenFlags.SINGLE_VNODE
            children = children[0]
        } else {
            childFlags = ChildrenFlags.KEYED_VNODES
            children = normalizeVNodes(children) // 生成key
        }
    } else if (children === null) {
        childFlags = ChildrenFlags.NO_CHILDREN
    } else if (children._isVNode) {
        childFlags = ChildrenFlags.SINGLE_VNODE
    } else {
        // 其他情况都作为文本节点处理，即单个子节点，会调用 createTextVNode 创建纯文本类型的 VNode
        childFlags = ChildrenFlags.SINGLE_VNODE
        children = createTextVNode(children + '')
    }

    return {
        flags,
        childFlags,
        _isVNode: true,
        children,
        tag,
        data,
        el: null
    }
}
const serialization = function (args) {
    let res = ''
    for (let item of args) {
        if (typeof item === 'string') {
            res += item
        } else if (Array.isArray(item)) {
            res += (' ' + item.join(' '))
        } else {
            for (let key in item) {
                if (item[key]) {
                    res += (' ' + key)
                }
            }
        }
    }
    return res
}
const mountElement = function (vnode, container, isSVG) {
    const { childFlags, children, data } = vnode
    const el = document.createElement(vnode.tag)
    for (let key in data) {
        switch (key) {
            case 'style':
                for (let k in data.style) {
                    el.style[k] = data.style[k]
                }
                break
            case 'class':
                el.className = serialization(data.class)
                break
            default:
                const domPropsRE = /\[A-Z]|^(?:value|checked|selected|muted)$/
                if (key[0] === 'o' && key[1] === 'n') {
                    // 事件
                    el.addEventListener(key.slice(2).toLowerCase(), data[key])
                } else if (domPropsRE.test(key)) {
                    // 当作 DOM Prop 处理
                    el[key] = data[key]
                } else {
                    // 当作 Attr 处理
                    el.setAttribute(key, data[key])
                }
                break
        }
    }
    // children
    if (childFlags !== ChildrenFlags.NO_CHILDREN) {
        if (childFlags & ChildrenFlags.SINGLE_VNODE) {
            mount(children, el, isSVG)
        } else if (childFlags & ChildrenFlags.MULTIPLE_VNODES) {
            for (let i = 0; i < children.length; i++) {
                mount(children[i], el, isSVG)
            }
        }
    }

    vnode.el = el
    container.appendChild(el)
}
const mountStatefulComponent = function (vnode, container, isSVG) {
  // 创建组件实例
  const instance = (vnode.children = new vnode.tag())
  instance.$props = vnode.data
  instance._update = function () {
    // 如果 instance._mounted 为真，说明组件已挂载，应该执行更新操作
    if (instance._mounted) {
      // 1、拿到旧的 VNode
      const prevVNode = instance.$vnode
      // 2、重渲染新的 VNode
      const nextVNode = (instance.$vnode = instance.render())
      // 3、patch 更新
      patch(prevVNode, nextVNode, prevVNode.el.parentNode)
      // 4、更新 vnode.el 和 $el
      instance.$el = vnode.el = instance.$vnode.el
    } else {
      // 1、渲染VNode
      instance.$vnode = instance.render()
      // 2、挂载
      mount(instance.$vnode, container, isSVG)
      // 3、组件已挂载的标识
      instance._mounted = true
      // 4、el 属性值 和 组件实例的 $el 属性都引用组件的根DOM元素
      instance.$el = vnode.el = instance.$vnode.el
      // 5、调用 mounted 钩子
      instance.mounted && instance.mounted()
    }
  }

  instance._update()

}

const mountFunctionalComponent = function (vnode, container, isSVG) {
  // 获取 props
  const props = vnode.data
  // 获取 VNode
  const $vnode = (vnode.children = vnode.tag(props))
  // 挂载
  mount($vnode, container, isSVG)
  // el 元素引用该组件的根元素
  vnode.el = $vnode.el
}

const mountComponent = function (vnode, container, isSVG) {
  if (vnode.flags & VNodeFlags.COMPONENT_STATEFUL) {
    mountStatefulComponent(vnode, container, isSVG)
  } else {
    mountFunctionalComponent(vnode, container, isSVG)
  }
}

const mountText = function (vnode, container) {
    const el = document.createTextNode(vnode.children)
    vnode.el = el
    container.appendChild(el)
}

const mountFragment = function (vnode, container, isSVG) {
    const { children, childFlags } = vnode
    if (childFlags !== ChildrenFlags.NO_CHILDREN) {
        if (childFlags & ChildrenFlags.SINGLE_VNODE) {
            mount(children, container, isSVG)
            vnode.el = children.el
        } else if (childFlags & ChildrenFlags.MULTIPLE_VNODES) {
            for (let i = 0; i < children.length; i++) {
                mount(children[i], container, isSVG)
            }
            vnode.el = children[0].el
        }
    } else {
        // 创建空文本节点占位
        let placeholder = createTextVNode('')
        mountText(placeholder, container)
        vnode.el = placeholder.el
    }
}

const mountPortal = function (vnode, container, isSVG) {
  const { tag, children, childFlags } = vnode
  // 获取挂载点
  const target = typeof tag === 'string' ? document.querySelector(tag) : tag
  if (childFlags & ChildrenFlags.SINGLE_VNODE) {
    // 将 children 挂载到 target 上，而非 container
    mount(children, target, isSVG)
  } else if (childFlags & ChildrenFlags.MULTIPLE_VNODES) {
    for (let i = 0; i < children.length; i++) {
      // 将 children 挂载到 target 上，而非 container
      mount(children[i], target, isSVG)
    }
  }

  // 占位的空文本节点
  const placeholder = createTextVNode('')
  // 将该节点挂载到 container 中
  mountText(placeholder, container, null)
  // el 属性引用该节点
  vnode.el = placeholder.el
}

var mount = function (vnode, container, isSVG) {
    // 判断vnode的flag
    if (vnode.flags & VNodeFlags.ELEMENT) {
        mountElement(vnode, container, isSVG) // 挂载普通标签
    } else if (vnode.flags & VNodeFlags.COMPONENT) {
        mountComponent(vnode, container, isSVG) // 挂载组件
    } else if (vnode.flags & VNodeFlags.TEXT) {
        mountText(vnode, container) // 挂载纯文本
    } else if (vnode.flags & VNodeFlags.FRAGMENT) {
        mountFragment(vnode, container, isSVG) // 挂载Fragment
    } else if (vnode.flags & VNodeFlags.PORTAL) {
        mountPortal(vnode, container, isSVG) // 挂载Portal
    }
}




const replaceVNode = function (prevVNode, nextVNode, container) {
    container.removeChild(prevVNode.el)
    // 如果将要被移除的 VNode 类型是组件，则需要调用该组件实例的 unmounted 钩子函数
    if (prevVNode.flags & VNodeFlags.COMPONENT_STATEFUL_NORMAL) {
      // 类型为有状态组件的 VNode，其 children 属性被用来存储组件实例对象
      const instance = prevVNode.children
      instance.unmounted && instance.unmounted()
    }
    mount(nextVNode, container)
}

const patchData = function (el, key, prevValue, nextValue, isSVG) {
  switch (key) {
    case 'style':
      for (let k in nextValue) {
        el.style[k] = nextValue[k]
      }
      for (let k in prevValue) {
        if (!nextValue || !nextValue.hasOwnProperty(k)) {
          el.style[k] = ''
        }
      }
      break
    case 'class':
      if (nextValue) {
        if (isSVG) {
          el.setAttribute('class', serialization(nextValue))
        } else {
          el.className = serialization(nextValue)
        }
      }
      break
    default:
      const domPropsRE = /\[A-Z]|^(?:value|checked|selected|muted)$/
      if (key[0] === 'o' && key[1] === 'n') {
        // 事件
        // 移除旧事件
        if (prevValue) {
          el.removeEventListener(key.slice(2), prevValue)
        }
        // 添加新事件
        if (nextValue) {
          el.addEventListener(key.slice(2), nextValue)
        }
      } else if (domPropsRE.test(key)) {
        // 当作 DOM Prop 处理
        el[key] = nextValue
      } else {
        // 当作 Attr 处理
        el.setAttribute(key, nextValue)
      }
      break
  }
}

// 3 * 3 = 9种情况
const patchChildren = function (prevChildFlags, nextChildFlags, prevChildren, nextChildren, container) {
  switch (prevChildFlags) {
    case ChildrenFlags.SINGLE_VNODE:
      switch (nextChildFlags) {
        case ChildrenFlags.SINGLE_VNODE:
          patch(prevChildren, nextChildren, container)
          break
        case ChildrenFlags.NO_CHILDREN:
          container.removeChild(prevChildren.el)
          break
        default:
          container.removeChild(prevChildren.el)
          for (let i = 0; i < nextChildren.length; i++) {
            mount(nextChildren[i], container)
          }
          break
      }
      break
    case ChildrenFlags.NO_CHILDREN:
      switch (nextChildFlags) {
        case ChildrenFlags.SINGLE_VNODE:
          mount(nextChildren, container)
          break
        case ChildrenFlags.NO_CHILDREN:
          break
        default:
          for (let i = 0; i < nextChildren.length; i++) {
            mount(nextChildren[i], container)
          }
          break
      }
      break
    default:
      switch (nextChildFlags) {
        case ChildrenFlags.SINGLE_VNODE:
          for(let i = 0; i < prevChildren.length; i++) {
            container.removeChild(prevChildren[i].el)
          }
          mount(nextChildren, container)
          break
        case ChildrenFlags.NO_CHILDREN:
          for(let i = 0; i < prevChildren.length; i++) {
            container.removeChild(prevChildren[i].el)
          }
          break
        default:
          // 遍历旧的子节点，将其全部移除
          for (let i = 0; i < prevChildren.length; i++) {
            container.removeChild(prevChildren[i].el)
          }
          // 遍历新的子节点，将其全部添加
          for (let i = 0; i < nextChildren.length; i++) {
            mount(nextChildren[i], container)
          }
          break
      }
      break
  }
}

const patchElement = function (prevVNode, nextVNode, container) {
  if (prevVNode.tag !== nextVNode.tag) {
    replaceVNode(prevVNode, nextVNode, container)
    return
  }
  // 拿到 el 元素，注意这时要让 nextVNode.el 也引用该元素
  const el = (nextVNode.el = prevVNode.el)
  // 拿到 新旧 VNodeData
  const prevData = prevVNode.data
  const nextData = nextVNode.data
  // 新的 VNodeData 存在时才有必要更新
  if (nextData) {
    // 遍历新的 VNodeData
    for (let key in nextData) {
      // 根据 key 拿到新旧 VNodeData 值
      const prevValue = prevData[key]
      const nextValue = nextData[key]
      patchData(el, key, prevValue, nextValue)
    }
  }
  if (prevData) {
    // 遍历旧的 VNodeData，将已经不存在于新的 VNodeData 中的数据移除
    for (let key in prevData) {
      const prevValue = prevData[key]
      if (prevValue && (!nextData || !nextData.hasOwnProperty(key))) {
        // 第四个参数为 null，代表移除数据
        patchData(el, key, prevValue, null)
      }
    }
  }

  // 调用 patchChildren 函数递归地更新子节点
  patchChildren(
    prevVNode.childFlags, // 旧的 VNode 子节点的类型
    nextVNode.childFlags, // 新的 VNode 子节点的类型
    prevVNode.children,   // 旧的 VNode 子节点
    nextVNode.children,   // 新的 VNode 子节点
    el                    // 当前标签元素，即这些子节点的父节点
  )
}

const patchText = function (prevVNode, nextVNode) {
    const el = (nextVNode.el = prevVNode.el)
    if (nextVNode.children !== prevVNode.children) {
        el.nodeValue = nextVNode.children
    }
}

const patchComponent = function (prevVNode, nextVNode, container) {
  if (nextVNode.tag !== prevVNode.tag) {
    replaceVNode(prevVNode, nextVNode, container)
  } else if (nextVNode.flags & VNodeFlags.COMPONENT_STATEFUL_NORMAL) {
      // 1、获取组件实例
      const instance = (nextVNode.children = prevVNode.children)
      // 2、更新 props
      instance.$props = nextVNode.data
      // 3、更新组件
      instance._update()
  } else {
    console.log('hehe')
  }
}

const patch = function (prevVNode, nextVNode, container) {
    const nextFlags = nextVNode.flags
    const prevFlags = prevVNode.flags
    if (prevFlags !== nextFlags) { // flags不同，无需对比直接替换
        replaceVNode(prevVNode, nextVNode, container)
    } else if (nextFlags & VNodeFlags.ELEMENT) {
        patchElement(prevVNode, nextVNode, container)
    } else if (nextFlags & VNodeFlags.COMPONENT) {
        patchComponent(prevVNode, nextVNode, container)
    } else if (nextFlags & VNodeFlags.TEXT) {
        patchText(prevVNode, nextVNode)
    } else if (nextFlags & VNodeFlags.FRAGMENT) {
        patchFragment(prevVNode, nextVNode, container)
    } else if (nextFlags & VNodeFlags.PORTAL) {
        patchPortal(prevVNode, nextVNode, container)
    }
}
const render = function (vnode, container) {
    const prevVNode = container.vnode
    if (!prevVNode) {
        if (vnode) {
            let isSVG = vnode.flags & VNodeFlags.ELEMENT_SVG
            mount(vnode, container, isSVG)
            container.vnode = vnode
        }
    } else {
        if (vnode) {
            patch(prevVNode, vnode, container)
            container.vnode = vnode
        } else {
            container.removeChild(prevVNode.el)
            container.vnode = null
        }
    }
}

class ParentComponent {
    localMsg = 'from parent'
    isTrust = false

    mounted () {
      setTimeout(() => {
        this.localMsg = '2s after'
        this.isTrust = true
        this._update()
      }, 2000);
    }
    render () {
        const text = this.localMsg
        return h(MyFunctionalComponent, { text: this.localMsg })
    }
}
class ChildComponent1 {
  render () {
    return h('div', null, this.$props.text)
  }
}

class ChildComponent2 {
  render () {
    return h('div', null, '222222222')
  }
}

function MyParent (props) {
  return h(
    MyFunctionalComponent,
    { text: props.text }
  )
}
function MyFunctionalComponent(props) {
  // 返回要渲染的内容描述，即 VNode
  return h(
    'div',
    {
      style: {
        background: 'red'
      }
    },
    props.text
  )
}

const vnode = h(ParentComponent, { text: '函数式组件' }, null)

render(vnode, document.getElementById('app'))


</script>